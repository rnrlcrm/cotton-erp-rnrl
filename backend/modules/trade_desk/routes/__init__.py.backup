"""
Availability Engine REST API Routes

Re-exports the router from availability_routes.py
"""

from backend.modules.trade_desk.routes.availability_routes import router

__all__ = ["router"]


# ========================
# Public REST APIs
# ========================

@router.post(
    "",
    response_model=AvailabilityResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create new availability",
    description="Post new inventory availability with AI enhancements (auto-normalize, anomaly detection, embeddings)"
)
async def create_availability(
    request: AvailabilityCreateRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id),
    seller_id: UUID = Depends(get_current_seller_id)
):
    """
    Create new availability posting.
    
    Workflow:
    1. Validates seller location (SELLER=own, TRADER=any)
    2. Auto-normalizes quality parameters
    3. Detects price anomalies
    4. Calculates AI score vector
    5. Auto-fetches delivery coordinates
    6. Creates availability (status=DRAFT)
    7. Emits availability.created event
    
    Returns: Created availability with AI enhancements
    """
    service = AvailabilityService(db)
    
    try:
        availability = await service.create_availability(
            seller_id=seller_id,
            commodity_id=request.commodity_id,
            location_id=request.location_id,
            total_quantity=request.total_quantity,
            base_price=request.base_price,
            price_matrix=request.price_matrix,
            quality_params=request.quality_params,
            market_visibility=request.market_visibility,
            allow_partial_order=request.allow_partial_order,
            min_order_quantity=request.min_order_quantity,
            delivery_terms=request.delivery_terms,
            delivery_address=request.delivery_address,
            expiry_date=request.expiry_date,
            created_by=user_id,
            notes=request.notes,
            tags={"tags": request.tags} if request.tags else None
        )
        
        return AvailabilityResponse.from_orm(availability)
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post(
    "/search",
    response_model=AvailabilitySearchResponse,
    summary="AI-powered smart search",
    description="Multi-criteria search with vector similarity, quality tolerance, price range, geo-proximity"
)
async def search_availabilities(
    request: AvailabilitySearchRequest,
    db: AsyncSession = Depends(get_db),
    buyer_id: UUID = Depends(get_current_buyer_id)
):
    """
    AI-powered smart search for compatible availabilities.
    
    Features:
    - Vector similarity matching (ai_score_vector)
    - Quality tolerance fuzzy matching
    - Price range with tolerance
    - Geo-spatial distance filtering
    - Market visibility access control
    - Ranked by match score (0.0 to 1.0)
    
    Returns: Ranked list of availabilities with match scores and distances
    """
    service = AvailabilityService(db)
    
    results = await service.search_availabilities(
        buyer_id=buyer_id,
        commodity_id=request.commodity_id,
        quality_params=request.quality_params,
        quality_tolerance=request.quality_tolerance,
        min_price=request.min_price,
        max_price=request.max_price,
        price_tolerance_pct=request.price_tolerance_pct,
        location_id=request.location_id,
        delivery_region=request.delivery_region,
        max_distance_km=request.max_distance_km,
        buyer_latitude=request.buyer_latitude,
        buyer_longitude=request.buyer_longitude,
        min_quantity=request.min_quantity,
        allow_partial=request.allow_partial,
        market_visibility=request.market_visibility,
        exclude_anomalies=request.exclude_anomalies,
        skip=request.skip,
        limit=request.limit
    )
    
    return AvailabilitySearchResponse(
        results=[
            {
                "availability": AvailabilityResponse.from_orm(r["availability"]),
                "match_score": r["match_score"],
                "distance_km": r["distance_km"],
                "ai_confidence": r["ai_confidence"],
                "ai_suggested_price": r["ai_suggested_price"]
            }
            for r in results
        ],
        total=len(results),
        skip=request.skip,
        limit=request.limit
    )


@router.get(
    "/my",
    response_model=List[AvailabilityResponse],
    summary="Get seller's inventory",
    description="Get all availabilities posted by current seller"
)
async def get_my_availabilities(
    status_filter: str = Query(None, description="Filter by status (ACTIVE, DRAFT, etc.)"),
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db),
    seller_id: UUID = Depends(get_current_seller_id)
):
    """
    Get seller's inventory list.
    
    Returns: List of seller's availabilities (newest first)
    """
    service = AvailabilityService(db)
    
    availabilities = await service.get_seller_availabilities(
        seller_id=seller_id,
        status=status_filter,
        skip=skip,
        limit=limit
    )
    
    return [AvailabilityResponse.from_orm(a) for a in availabilities]


@router.get(
    "/{availability_id}",
    response_model=AvailabilityResponse,
    summary="Get availability by ID",
    responses={404: {"model": ErrorResponse}}
)
async def get_availability(
    availability_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Get single availability by ID.
    
    Returns: Availability details with relationships (commodity, location, seller)
    """
    service = AvailabilityService(db)
    
    availability = await service.repo.get_by_id(availability_id, load_relationships=True)
    
    if not availability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability not found"
        )
    
    return AvailabilityResponse.from_orm(availability)


@router.put(
    "/{availability_id}",
    response_model=AvailabilityResponse,
    summary="Update availability",
    responses={404: {"model": ErrorResponse}}
)
async def update_availability(
    availability_id: UUID,
    request: AvailabilityUpdateRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id)
):
    """
    Update availability with intelligent change detection.
    
    Features:
    - Auto-detects changes and emits micro-events
    - Re-runs AI processing on relevant changes
    - Emits: visibility_changed, price_changed, quantity_changed
    
    Returns: Updated availability
    """
    service = AvailabilityService(db)
    
    updates = request.model_dump(exclude_unset=True)
    
    availability = await service.update_availability(
        availability_id=availability_id,
        updated_by=user_id,
        **updates
    )
    
    if not availability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability not found"
        )
    
    return AvailabilityResponse.from_orm(availability)


@router.post(
    "/{availability_id}/approve",
    response_model=AvailabilityResponse,
    summary="Approve availability",
    description="Approve availability (change status from DRAFT to ACTIVE)",
    responses={404: {"model": ErrorResponse}}
)
async def approve_availability(
    availability_id: UUID,
    request: ApprovalRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id)
):
    """
    Approve availability posting.
    
    Changes status: DRAFT → ACTIVE
    Makes availability visible to buyers (per market_visibility rules)
    
    Returns: Approved availability
    """
    service = AvailabilityService(db)
    
    availability = await service.approve_availability(
        availability_id=availability_id,
        approved_by=user_id,
        approval_notes=request.approval_notes
    )
    
    if not availability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability not found"
        )
    
    return AvailabilityResponse.from_orm(availability)


@router.get(
    "/{availability_id}/negotiation-score",
    response_model=NegotiationReadinessResponse,
    summary="Get negotiation readiness score",
    description="Calculate how ready availability is for negotiation (0.0 to 1.0)",
    responses={404: {"model": ErrorResponse}}
)
async def get_negotiation_score(
    availability_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Calculate negotiation readiness score.
    
    Factors:
    - Quality completeness (40% weight)
    - Price available (30% weight)
    - Delivery terms clarity (20% weight)
    - Quantity adequate (10% weight)
    
    Returns: Score + factor breakdown + recommendations
    """
    service = AvailabilityService(db)
    
    result = await service.calculate_negotiation_readiness_score(availability_id)
    
    if result.get("readiness_score") == 0.0 and "not found" in result.get("recommendations", [""])[0].lower():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability not found"
        )
    
    return NegotiationReadinessResponse(**result)


@router.get(
    "/{availability_id}/similar",
    response_model=List[SimilarCommodityResponse],
    summary="Get similar commodities",
    description="AI-powered commodity similarity suggestions (e.g., Cotton 29mm → 28mm/30mm/yarn)",
    responses={404: {"model": ErrorResponse}}
)
async def get_similar_commodities(
    availability_id: UUID,
    max_suggestions: int = Query(5, ge=1, le=20),
    db: AsyncSession = Depends(get_db)
):
    """
    Suggest similar commodities using AI.
    
    Examples:
    - Cotton 29mm → Cotton 28mm, 30mm, Cotton Yarn
    - Gold 999 → Gold 995, Gold Coins
    
    Returns: List of similar commodities with similarity scores
    """
    service = AvailabilityService(db)
    
    availability = await service.repo.get_by_id(availability_id)
    if not availability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Availability not found"
        )
    
    suggestions = await service.suggest_similar_commodities(
        commodity_id=availability.commodity_id,
        quality_params=availability.quality_params,
        max_suggestions=max_suggestions
    )
    
    return [SimilarCommodityResponse(**s) for s in suggestions]


# ========================
# Internal APIs (for Negotiation Engine)
# ========================

@router.post(
    "/{availability_id}/reserve",
    response_model=AvailabilityResponse,
    summary="Reserve quantity (INTERNAL API)",
    description="Reserve quantity for negotiation (24h hold). Used by Negotiation Engine (Engine 4).",
    responses={400: {"model": ErrorResponse}, 404: {"model": ErrorResponse}},
    tags=["Availability Engine", "Internal APIs"]
)
async def reserve_quantity(
    availability_id: UUID,
    request: ReserveRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id),
    buyer_id: UUID = Depends(get_current_buyer_id)
):
    """
    Reserve quantity for negotiation (internal API).
    
    Workflow:
    1. Validates quantity available
    2. Reserves quantity (temporary hold)
    3. Changes status to RESERVED if fully reserved
    4. Emits availability.reserved event
    5. Emits availability.quantity_changed micro-event
    
    Returns: Updated availability
    """
    service = AvailabilityService(db)
    
    try:
        availability = await service.reserve_availability(
            availability_id=availability_id,
            quantity=request.quantity,
            buyer_id=buyer_id,
            reservation_hours=request.reservation_hours,
            reserved_by=user_id
        )
        
        return AvailabilityResponse.from_orm(availability)
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post(
    "/{availability_id}/release",
    response_model=AvailabilityResponse,
    summary="Release reserved quantity (INTERNAL API)",
    description="Release reserved quantity (negotiation failed/expired). Used by Negotiation Engine.",
    responses={400: {"model": ErrorResponse}, 404: {"model": ErrorResponse}},
    tags=["Availability Engine", "Internal APIs"]
)
async def release_quantity(
    availability_id: UUID,
    request: ReleaseRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id),
    buyer_id: UUID = Depends(get_current_buyer_id)
):
    """
    Release reserved quantity (internal API).
    
    Workflow:
    1. Validates reserved quantity
    2. Releases quantity back to available
    3. Changes status back to ACTIVE if no reservations remain
    4. Emits availability.released event
    5. Emits availability.quantity_changed micro-event
    
    Returns: Updated availability
    """
    service = AvailabilityService(db)
    
    try:
        availability = await service.release_availability(
            availability_id=availability_id,
            quantity=request.quantity,
            buyer_id=buyer_id,
            released_by=user_id,
            reason=request.reason
        )
        
        return AvailabilityResponse.from_orm(availability)
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post(
    "/{availability_id}/mark-sold",
    response_model=AvailabilityResponse,
    summary="Mark as sold (INTERNAL API)",
    description="Mark availability as sold (convert to trade). Used by Trade Finalization Engine (Engine 5).",
    responses={400: {"model": ErrorResponse}, 404: {"model": ErrorResponse}},
    tags=["Availability Engine", "Internal APIs"]
)
async def mark_as_sold(
    availability_id: UUID,
    request: MarkSoldRequest,
    db: AsyncSession = Depends(get_db),
    user_id: UUID = Depends(get_current_user_id),
    buyer_id: UUID = Depends(get_current_buyer_id)
):
    """
    Mark availability as sold (internal API).
    
    Workflow:
    1. Validates reserved quantity
    2. Converts reserved → sold
    3. Changes status to SOLD if fully sold
    4. Emits availability.sold event
    5. Emits availability.quantity_changed micro-event
    6. Triggers Trade Finalization Engine
    
    Returns: Updated availability
    """
    service = AvailabilityService(db)
    
    try:
        availability = await service.mark_as_sold(
            availability_id=availability_id,
            quantity=request.quantity,
            buyer_id=buyer_id,
            trade_id=request.trade_id,
            sold_price=request.sold_price,
            sold_by=user_id
        )
        
        return AvailabilityResponse.from_orm(availability)
    
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
